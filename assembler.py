import struct
from binascii import hexlify, unhexlify

little_endian = lambda x: struct.pack("<I", x)
reg_bytes = lambda x: int.to_bytes(x, 1, "little")

HASHES =  {0x0: 0x4,
0x1: 0x50007df,
0x2: 0x6000972,
0x3: 0x7000b05,
0x4: 0x0,
0x5: 0x1000193,
0x6: 0x2000326,
0x7: 0x30004b9,
0x8: 0xc0012e4,
0x9: 0xd001477,
0xa: 0xe00160a,
0xb: 0xf00179d,
0xc: 0x8000c98,
0xd: 0x9000e2b,
0xe: 0xa000fbe,
0xf: 0xb001151,
0x10: 0x14001f7c,
0x11: 0x1500210f,
0x12: 0x160022a2,
0x13: 0x17002435,
0x14: 0x10001930,
0x15: 0x11001ac3,
0x16: 0x12001c56,
0x17: 0x13001de9,
0x18: 0x1c002c14,
0x19: 0x1d002da7,
0x1a: 0x1e002f3a,
0x1b: 0x1f0030cd,
0x1c: 0x180025c8,
0x1d: 0x1900275b,
0x1e: 0x1a0028ee,
0x1f: 0x1b002a81,
0x20: 0x240038ac,
0x21: 0x25003a3f,
0x22: 0x26003bd2,
0x23: 0x27003d65,
0x24: 0x20003260,
0x25: 0x210033f3,
0x26: 0x22003586,
0x27: 0x23003719,
0x28: 0x2c004544,
0x29: 0x2d0046d7,
0x2a: 0x2e00486a,
0x2b: 0x2f0049fd,
0x2c: 0x28003ef8,
0x2d: 0x2900408b,
0x2e: 0x2a00421e,
0x2f: 0x2b0043b1,
0x30: 0x340051dc,
0x31: 0x3500536f,
0x32: 0x36005502,
0x33: 0x37005695,
0x34: 0x30004b90,
0x35: 0x31004d23,
0x36: 0x32004eb6,
0x37: 0x33005049,
0x38: 0x3c005e74,
0x39: 0x3d006007,
0x3a: 0x3e00619a,
0x3b: 0x3f00632d,
0x3c: 0x38005828,
0x3d: 0x390059bb,
0x3e: 0x3a005b4e,
0x3f: 0x3b005ce1,
0x40: 0x44006b0c,
0x41: 0x45006c9f,
0x42: 0x46006e32,
0x43: 0x47006fc5,
0x44: 0x400064c0,
0x45: 0x41006653,
0x46: 0x420067e6,
0x47: 0x43006979,
0x48: 0x4c0077a4,
0x49: 0x4d007937,
0x4a: 0x4e007aca,
0x4b: 0x4f007c5d,
0x4c: 0x48007158,
0x4d: 0x490072eb,
0x4e: 0x4a00747e,
0x4f: 0x4b007611,
0x50: 0x5400843c,
0x51: 0x550085cf,
0x52: 0x56008762,
0x53: 0x570088f5,
0x54: 0x50007df0,
0x55: 0x51007f83,
0x56: 0x52008116,
0x57: 0x530082a9,
0x58: 0x5c0090d4,
0x59: 0x5d009267,
0x5a: 0x5e0093fa,
0x5b: 0x5f00958d,
0x5c: 0x58008a88,
0x5d: 0x59008c1b,
0x5e: 0x5a008dae,
0x5f: 0x5b008f41,
0x60: 0x64009d6c,
0x61: 0x65009eff,
0x62: 0x6600a092,
0x63: 0x6700a225,
0x64: 0x60009720,
0x65: 0x610098b3,
0x66: 0x62009a46,
0x67: 0x63009bd9,
0x68: 0x6c00aa04,
0x69: 0x6d00ab97,
0x6a: 0x6e00ad2a,
0x6b: 0x6f00aebd,
0x6c: 0x6800a3b8,
0x6d: 0x6900a54b,
0x6e: 0x6a00a6de,
0x6f: 0x6b00a871,
0x70: 0x7400b69c,
0x71: 0x7500b82f,
0x72: 0x7600b9c2,
0x73: 0x7700bb55,
0x74: 0x7000b050,
0x75: 0x7100b1e3,
0x76: 0x7200b376,
0x77: 0x7300b509,
0x78: 0x7c00c334,
0x79: 0x7d00c4c7,
0x7a: 0x7e00c65a,
0x7b: 0x7f00c7ed,
0x7c: 0x7800bce8,
0x7d: 0x7900be7b,
0x7e: 0x7a00c00e,
0x7f: 0x7b00c1a1,
0x80: 0x83ff3ccc,
0x81: 0x84ff3e5f,
0x82: 0x85ff3ff2,
0x83: 0x86ff4185, #DONOTUSE
0x84: 0x7fff3680,
0x85: 0x80ff3813,
0x86: 0x81ff39a6,
0x87: 0x82ff3b39,
0x88: 0x8bff4964,
0x89: 0x8cff4af7,
0x8a: 0x8dff4c8a,
0x8b: 0x8eff4e1d,
0x8c: 0x87ff4318,
0x8d: 0x88ff44ab,
0x8e: 0x89ff463e,
0x8f: 0x8aff47d1,
0x90: 0x93ff55fc,
0x91: 0x94ff578f,
0x92: 0x95ff5922,
0x93: 0x96ff5ab5,
0x94: 0x8fff4fb0,
0x95: 0x90ff5143,
0x96: 0x91ff52d6,
0x97: 0x92ff5469,
0x98: 0x9bff6294,
0x99: 0x9cff6427,
0x9a: 0x9dff65ba,
0x9b: 0x9eff674d,
0x9c: 0x97ff5c48,
0x9d: 0x98ff5ddb,
0x9e: 0x99ff5f6e,
0x9f: 0x9aff6101,
0xa0: 0xa3ff6f2c,
0xa1: 0xa4ff70bf,
0xa2: 0xa5ff7252,
0xa3: 0xa6ff73e5,
0xa4: 0x9fff68e0,
0xa5: 0xa0ff6a73,
0xa6: 0xa1ff6c06,
0xa7: 0xa2ff6d99,
0xa8: 0xabff7bc4,
0xa9: 0xacff7d57,
0xaa: 0xadff7eea,
0xab: 0xaeff807d,
0xac: 0xa7ff7578,
0xad: 0xa8ff770b,
0xae: 0xa9ff789e,
0xaf: 0xaaff7a31,
0xb0: 0xb3ff885c,
0xb1: 0xb4ff89ef,
0xb2: 0xb5ff8b82,
0xb3: 0xb6ff8d15,
0xb4: 0xafff8210,
0xb5: 0xb0ff83a3,
0xb6: 0xb1ff8536,
0xb7: 0xb2ff86c9,
0xb8: 0xbbff94f4,
0xb9: 0xbcff9687,
0xba: 0xbdff981a,
0xbb: 0xbeff99ad,
0xbc: 0xb7ff8ea8,
0xbd: 0xb8ff903b,
0xbe: 0xb9ff91ce,
0xbf: 0xbaff9361,
0xc0: 0xc3ffa18c,
0xc1: 0xc4ffa31f,
0xc2: 0xc5ffa4b2,
0xc3: 0xc6ffa645,
0xc4: 0xbfff9b40,
0xc5: 0xc0ff9cd3,
0xc6: 0xc1ff9e66,
0xc7: 0xc2ff9ff9,
0xc8: 0xcbffae24,
0xc9: 0xccffafb7,
0xca: 0xcdffb14a,
0xcb: 0xceffb2dd,
0xcc: 0xc7ffa7d8,
0xcd: 0xc8ffa96b,
0xce: 0xc9ffaafe,
0xcf: 0xcaffac91,
0xd0: 0xd3ffbabc,
0xd1: 0xd4ffbc4f,
0xd2: 0xd5ffbde2,
0xd3: 0xd6ffbf75,
0xd4: 0xcfffb470,
0xd5: 0xd0ffb603,
0xd6: 0xd1ffb796,
0xd7: 0xd2ffb929,
0xd8: 0xdbffc754,
0xd9: 0xdcffc8e7,
0xda: 0xddffca7a,
0xdb: 0xdeffcc0d,
0xdc: 0xd7ffc108,
0xdd: 0xd8ffc29b,
0xde: 0xd9ffc42e,
0xdf: 0xdaffc5c1,
0xe0: 0xe3ffd3ec,
0xe1: 0xe4ffd57f,
0xe2: 0xe5ffd712,
0xe3: 0xe6ffd8a5,
0xe4: 0xdfffcda0,
0xe5: 0xe0ffcf33,
0xe6: 0xe1ffd0c6,
0xe7: 0xe2ffd259,
0xe8: 0xebffe084,
0xe9: 0xecffe217,
0xea: 0xedffe3aa,
0xeb: 0xeeffe53d,
0xec: 0xe7ffda38,
0xed: 0xe8ffdbcb,
0xee: 0xe9ffdd5e,
0xef: 0xeaffdef1,
0xf0: 0xf3ffed1c,
0xf1: 0xf4ffeeaf,
0xf2: 0xf5fff042,
0xf3: 0xf6fff1d5,
0xf4: 0xefffe6d0,
0xf5: 0xf0ffe863,
0xf6: 0xf1ffe9f6,
0xf7: 0xf2ffeb89,
0xf8: 0xfbfff9b4,
0xf9: 0xfcfffb47,
0xfa: 0xfdfffcda,
0xfb: 0xfefffe6d,
0xfc: 0xf7fff368,
0xfd: 0xf8fff4fb,
0xfe: 0xf9fff68e,
0xff: 0xfafff821}

DIV_BY_ZERO_LOAD_REG_IMM32 = b'\xab'
INVALID_HANDLE_HASH_REG2 = b'\x10'
PRIV_INSTRUCTION_CMP_REG_REG = b'\xff'
ILLEGAL_INSTRUCTION_XOR_REG_REG = b'\x00'
NONE_GETCHAR_INTO_REGISTER = b'\xcd'
BREAKPOINT_ROL_REGISTER_IMM8 = b'\x73'

def LOAD_REG_IMM32(reg, imm32):
    return DIV_BY_ZERO_LOAD_REG_IMM32 + reg_bytes(reg) + little_endian(imm32)

def HASH_REG2():
    return INVALID_HANDLE_HASH_REG2

def CMP_REG_REG(reg1, reg2):
    return PRIV_INSTRUCTION_CMP_REG_REG + reg_bytes(reg1) + reg_bytes(reg2)

import random

def XOR_REG_REG(reg1, reg2):
    ops = list(range(0x100))
    ops.remove(0xab)
    ops.remove(0x10)
    ops.remove(0xff)
    ops.remove(0xcd)
    ops.remove(0x73)
    return reg_bytes(random.choice(ops)) + reg_bytes(reg1) + reg_bytes(reg2)

def GETCHAR_INTO_REGISTER(reg):
    return NONE_GETCHAR_INTO_REGISTER + reg_bytes(reg)

def ROL_REGISTER(reg, num):
    return BREAKPOINT_ROL_REGISTER_IMM8 + reg_bytes(reg) + reg_bytes(num)

def turnToC(buf):
    carr = "unsigned char opcodes[] = {"
    for b in buf:
        print(hexlify(bytes([b])))
        carr += "0x" + hexlify(bytes([b])).decode() + ","

    carr = carr[:-1]
    carr += "};"
    return carr

def LOAD_4_CHARS(tmp, final):
    buf = LOAD_REG_IMM32(final, 0)

    buf += GETCHAR_INTO_REGISTER(tmp)
    buf += XOR_REG_REG(final, tmp)

    buf += GETCHAR_INTO_REGISTER(tmp)
    buf += ROL_REGISTER(tmp, 8)
    buf += XOR_REG_REG(final, tmp)

    buf += GETCHAR_INTO_REGISTER(tmp)
    buf += ROL_REGISTER(tmp, 16)
    buf += XOR_REG_REG(final, tmp)

    buf += GETCHAR_INTO_REGISTER(tmp)
    buf += ROL_REGISTER(tmp, 24)
    buf += XOR_REG_REG(final, tmp)
    return buf

def main_flag():
    
    buf = LOAD_4_CHARS(0, 1)
    # b'KAF{'
    buf += LOAD_REG_IMM32(2, 0x7b46414b)
    buf += CMP_REG_REG(1,2)
    buf += LOAD_REG_IMM32(0, 0xdeadbeef)
    # NoW_
    buf += LOAD_4_CHARS(1,2) 
    buf += XOR_REG_REG(0, 2)
    # Correct result
    buf += LOAD_REG_IMM32(1, 0x81fad1a1)
    buf += CMP_REG_REG(0,1)

    # T
    # Initial hash of T: 0x50007df0
    # Rol 16: 0x7df05000
    buf += GETCHAR_INTO_REGISTER(2)
    buf += HASH_REG2()
    buf += ROL_REGISTER(2, 16)
    buf += LOAD_REG_IMM32(1, 0x7df05000)
    buf += CMP_REG_REG(1,2)
    # rY_2
    # chars in reg 0 now
    buf += LOAD_4_CHARS(1, 0)
    buf += XOR_REG_REG(0, 2)
    # xor with prev result, now 4faf0972
    # xor with last char in register, should be 2, now 7daf0972
    
    buf += LOAD_REG_IMM32(2, 0x7daf0972)
    buf += XOR_REG_REG(0, 1)
    buf += CMP_REG_REG(2, 0)

    #_R3V
    buf += LOAD_4_CHARS(0,1)
    buf += LOAD_REG_IMM32(2, 0x92fab19a)
    #92fab19a now
    buf += ROL_REGISTER(1, 19)
    buf += CMP_REG_REG(1,2)
    
    #3RSe
    buf += LOAD_4_CHARS(1,0)
    buf += LOAD_REG_IMM32(2, 0x83)
    buf += HASH_REG2()
    buf += XOR_REG_REG(0, 2)

    buf += LOAD_REG_IMM32(1, 0xe3ac13b6)
    buf += CMP_REG_REG(0, 1)

    #_Scr

    buf += LOAD_4_CHARS(2, 1)
    buf += LOAD_REG_IMM32(2, 0x91cf40e9)
    buf += XOR_REG_REG(0, 1)
    buf += CMP_REG_REG(0, 2)

    #ATcH

    buf += LOAD_4_CHARS(1,0)
    buf += LOAD_REG_IMM32(1, 0x90c6a882)
    buf += ROL_REGISTER(0, 1)
    buf += CMP_REG_REG(0, 1)


    # }
    buf += GETCHAR_INTO_REGISTER(0)
    buf += LOAD_REG_IMM32(1, ord("}"))
    buf += CMP_REG_REG(1,0)
    print (turnToC(buf))
    return buf

def fake_flag():
    buf = LOAD_4_CHARS(0,2)
    buf += LOAD_REG_IMM32(1, 0x7b4b4146)
    buf += CMP_REG_REG(1,2)
    buf += LOAD_4_CHARS(0,2)
    buf += LOAD_REG_IMM32(1, 0x316e5f65)
    buf += CMP_REG_REG(1,2)
    buf += LOAD_4_CHARS(0,2)
    buf += LOAD_REG_IMM32(1, 0x595f3343)
    buf += CMP_REG_REG(1,2)
    buf += LOAD_4_CHARS(0,2)
    buf += LOAD_REG_IMM32(1, 0x415f556f)
    buf += CMP_REG_REG(1,2)
    buf += LOAD_4_CHARS(0,2)
    buf += LOAD_REG_IMM32(1, 0x545f3372)
    buf += CMP_REG_REG(1,2)
    buf += LOAD_4_CHARS(0,2)
    buf += LOAD_REG_IMM32(1, 0x5f337572)
    buf += CMP_REG_REG(1,2)
    buf += LOAD_4_CHARS(0,2)
    buf += LOAD_REG_IMM32(1, 0x30786148)
    buf += CMP_REG_REG(1,2)

    buf += LOAD_REG_IMM32(1, 0)

    buf += GETCHAR_INTO_REGISTER(2)
    buf += XOR_REG_REG(1, 2)

    buf += GETCHAR_INTO_REGISTER(2)
    buf += ROL_REGISTER(2, 8)
    buf += XOR_REG_REG(1,2)
    
    buf += LOAD_REG_IMM32(2, 0x7d72)
    buf += CMP_REG_REG(1,2)
    buf += b'\x10' * (len(main_flag()) - len(buf))
    print (turnToC(buf))

if __name__ == "__main__":
    fake_flag()
    